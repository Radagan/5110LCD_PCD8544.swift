#if arch(arm) && os(Linux)
    //import SwiftyGPIO  //Uncomment this to use when using the package manager
    import Glibc
#else
    import Darwin //Needed for TravisCI
#endif
 
internal let LCDHEIGHT=48
internal let LCDWIDTH=84

public class PCD8544{
    var dc,rst,cs:GPIO
    var spi:VirtualSPI
    var pcd8544_buffer=[UInt8](count:LCDHEIGHT*LCDWIDTH/8, repeatedValue:0)
    var currentFont=[UInt8]()
    var currentFontWidth=0,currentFontHeight=0
 

    init(spi:VirtualSPI,dc:GPIO,rst:GPIO,cs:GPIO){
        self.spi=spi
        self.dc=dc
        self.rst=rst
        self.cs=cs    
        dc.direction = .OUT
        rst.direction = .OUT
        cs.direction = .OUT
        rst.value = 0
        usleep(UInt32(500*1000))
        rst.value = 1

        // get into the EXTENDED mode!
        command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );

        // LCD bias select (4 is optimal?)
        command(PCD8544_SETBIAS | 0x4);

        // set VOP
        command( PCD8544_SETVOP | 0x7f); // Experimentally determined //TODO

        // normal mode
        command(PCD8544_FUNCTIONSET);

        // Set display to Normal
        command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);

        // initial display line
        // set page address
        // set column address
        // write display data

        // set up a bounding box for screen updates
        updateBoundingBox(0, ymin:0, xmax:LCDWIDTH-1, ymax:LCDHEIGHT-1);
    }
    
    public func setContrast(value: Int){
        var v=value
        if (v > 0x7f) {
            v = 0x7f   
        }
        command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION );
        command(PCD8544_SETVOP | v); 
        command(PCD8544_FUNCTIONSET); 
    }

    // the most basic function, set a single pixel
    public func setPixel(x:Int, y:Int, color:LCDColor) {
        guard ((x < LCDWIDTH) && (y < LCDHEIGHT)) else {
            return
        }

        // x is which column
 	    if (color == .WHITE){
		    pcd8544_buffer[x + (y/8)*LCDWIDTH] |= UInt8(truncatingBitPattern:0x1 << y%8)
	    }else{                        
		    pcd8544_buffer[x + (y/8)*LCDWIDTH] &= UInt8(truncatingBitPattern:~(0x1 << y%8))
        }
        updateBoundingBox(x,ymin:y,xmax:x,ymax:y)
    }

    // the most basic function, get a single pixel
    public func getPixel(x:Int, y:Int)->UInt8 {
        guard ((x < LCDWIDTH) && (y < LCDHEIGHT)) else {
            return 0
        }

        return (pcd8544_buffer[x + (y/8)*LCDWIDTH] >> (UInt8(truncatingBitPattern:y)%8)) & 0x1; 
    } 

    public func drawImage(imageBuffer:[UInt8],x:Int,y:Int,width:Int,height:Int){
        var currentX=x
        var currentY=y

        for i in 0..<pcd8544_buffer.count {
            currentX = i % width 
            currentY = i / width
            setPixel(currentX, y:currentY, color: LCDColor(rawValue:imageBuffer[i]) ?? .BLACK)
        }
        updateBoundingBox(x, ymin:y, xmax:currentX, ymax:currentY)
    }          

    public func loadFontAsDefault(font:[UInt8], fontWidth:Int, fontHeight:Int){
        guard font.count == fontWidth*fontHeight else {
            return; //TODO error
        }
        self.currentFontHeight = fontHeight
        self.currentFontWidth = fontWidth
        self.currentFont = font
    }

    public func drawString(text:String, posX:Int, posY:Int, transparent:Bool){
        var cursorX=posX
        var cursorY=posY
        for scalar in text.unicodeScalars {
            if scalar.value == 10 {
                cursorY += currentFontHeight // \n character
                return
            }
            drawChar(scalar.value, posX:cursorX, posY:cursorY, transparent:transparent)
            cursorX += currentFontWidth
        }        
        updateBoundingBox(posX, ymin:posY, xmax:cursorX+currentFontWidth, ymax:cursorY+currentFontHeight)
    }

    public func nextFontRow(x:Int, y:Int) ->(x:Int,y:Int){
        return (x,y+currentFontHeight)
    }

    public func nextFontColumn(x:Int, y:Int) ->(x:Int,y:Int){
        return (x+currentFontWidth,y)
    }

    // Add an opaque char to the buffer
    private func drawChar(charCode:UInt32, posX:Int, posY:Int, transparent:Bool){
        guard (charCode>64)&&(charCode<127) else {
            return //Unprintable character
        }
        guard (posX+currentFontWidth<LCDWIDTH)&&(posY+currentFontHeight<LCDHEIGHT) else {
            return //Character outside of screen borders
        } 
        
        for row in 0...7 {
            if transparent {
		        pcd8544_buffer[posX + ((posY+row)/8)*LCDWIDTH] |= currentFont[(Int(charCode)-65)*8+row]
            }else{
		        pcd8544_buffer[posX + ((posY+row)/8)*LCDWIDTH] = currentFont[(Int(charCode)-65)*8+row]
            }
        }
    }
    

    public func display(){
        var col,maxcol:Int
  
        for p in 0...5 {
            // check if this page is part of update
            if ( yUpdateMin >= ((p+1)*8) ) {
                continue;   // nope, skip it!
            }
            if (yUpdateMax < p*8) {
                break;
            }

            command(PCD8544_SETYADDR | p);

            col = xUpdateMin;
            maxcol = xUpdateMax;

            command(PCD8544_SETXADDR | col);

            dc.value = 1 
            cs.value = 0
            for c in col...maxcol {
                spi.sendByte(pcd8544_buffer[(LCDWIDTH*p)+c]);
            }
            cs.value = 1
        }
       
        command(PCD8544_SETYADDR );  // no idea why this is necessary but it is to finish the last byte?

        xUpdateMin = LCDWIDTH - 1;
        xUpdateMax = 0;
        yUpdateMin = LCDHEIGHT-1;
        yUpdateMax = 0;
    } 
 

    // clear everything
    public func clearDisplay() {
        for i in 0..<pcd8544_buffer.count {
            pcd8544_buffer[i] = 0
        }
        updateBoundingBox(0, ymin:0, xmax:LCDWIDTH-1, ymax:LCDHEIGHT-1);
    } 


    private func command(commandcode:Int){
        dc.value = 0
        cs.value = 0
        spi.sendByte(UInt8(truncatingBitPattern:commandcode))
        cs.value = 1
    }

    private func data(data:UInt8){
        dc.value = 1
        cs.value = 0
        spi.sendByte(data)
        cs.value = 1
    }
         
    private var xUpdateMin:Int=0, xUpdateMax:Int=0, yUpdateMin:Int=0, yUpdateMax:Int=0  
    
    private func updateBoundingBox(xmin:Int, ymin:Int, xmax:Int, ymax:Int) {
        //TODO check bounds
        xUpdateMin = (xmin < xUpdateMin) ? xmin : xUpdateMin
        xUpdateMax = (xmax > xUpdateMax) ? xmax : xUpdateMax
        yUpdateMin = (ymin < yUpdateMin) ? ymin : yUpdateMin
        yUpdateMax = (ymax > yUpdateMax) ? ymax : yUpdateMax
    }
  
}

//Swift logo monochrome image
//Create your own at:
//http://www.rinkydinkelectronics.com/t_imageconverter_mono.php
//
public let swift_logo:[UInt8] = [               
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0010 (16) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0020 (32) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x70,   // 0x0030 (48) pixels
0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0040 (64) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0050 (80) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0060 (96) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x1C, 0x38, 0x70, 0xF0, 0xE0,   // 0x0070 (112) pixels
0xC3, 0x87, 0x8E, 0x1C, 0x78, 0xF0, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0080 (128) pixels
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x3F, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0x80, 0x00,   // 0x0090 (144) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00A0 (160) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00B0 (176) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00C0 (192) pixels
0x00, 0x00, 0x00, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7E, 0xFC, 0xFD, 0xFB, 0xFF, 0xFF, 0xFF, 0xFE,   // 0x00D0 (208) pixels
0xFE, 0xFC, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // 0x00E0 (224) pixels
0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x00F0 (240) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0100 (256) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xC0,   // 0x0110 (272) pixels
0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,   // 0x0120 (288) pixels
0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // 0x0130 (304) pixels
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0140 (320) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0150 (336) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x0160 (352) pixels
0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x3E, 0x7E, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC,   // 0x0170 (368) pixels
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   // 0x0180 (384) pixels
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8,   // 0x0190 (400) pixels
0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01A0 (416) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01B0 (432) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01C0 (448) pixels
0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,   // 0x01D0 (464) pixels
0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01,   // 0x01E0 (480) pixels
0x01, 0x03, 0x07, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   // 0x01F0 (496) pixels
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]

// Font array, each character composed by 8 byte elements,
// one for each of the 8 rows of the 8x8 bit sprite  
// Create your own at:
// http://www.rinkydinkelectronics.com/t_make_font_file_mono.php
//
public let SinclairS_Font:[UInt8]=[
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // <space>
0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x00,  // !
0x14,0x14,0x00,0x00,0x00,0x00,0x00,0x00,  // "
0x00,0x24,0x7E,0x24,0x24,0x7E,0x24,0x00,  // #
0x10,0x7C,0x50,0x7C,0x14,0x7C,0x10,0x00,  // $
0x00,0x62,0x64,0x08,0x10,0x26,0x46,0x00,  // %
0x00,0x10,0x28,0x10,0x2A,0x44,0x3A,0x00,  // &
0x00,0x08,0x10,0x00,0x00,0x00,0x00,0x00,  // '
0x00,0x08,0x10,0x10,0x10,0x10,0x08,0x00,  // (
0x00,0x10,0x08,0x08,0x08,0x08,0x10,0x00,  // )
0x00,0x00,0x28,0x10,0x7C,0x10,0x28,0x00,  // *
0x00,0x00,0x10,0x10,0x7C,0x10,0x10,0x00,  // +
0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x10,  // ,
0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,  // -
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,  // .
0x00,0x00,0x04,0x08,0x10,0x20,0x40,0x00,  // /

0x00,0x78,0x8C,0x94,0xA4,0xC4,0x78,0x00,  // 0
0x00,0x60,0xA0,0x20,0x20,0x20,0xF8,0x00,  // 1
0x00,0x78,0x84,0x04,0x78,0x80,0xFC,0x00,  // 2
0x00,0x78,0x84,0x18,0x04,0x84,0x78,0x00,  // 3
0x00,0x10,0x30,0x50,0x90,0xFC,0x10,0x00,  // 4
0x00,0xFC,0x80,0xF8,0x04,0x84,0x78,0x00,  // 5
0x00,0x78,0x80,0xF8,0x84,0x84,0x78,0x00,  // 6
0x00,0xFC,0x04,0x08,0x10,0x20,0x20,0x00,  // 7
0x00,0x78,0x84,0x78,0x84,0x84,0x78,0x00,  // 8
0x00,0x78,0x84,0x84,0x7C,0x04,0x78,0x00,  // 9
0x00,0x00,0x00,0x10,0x00,0x00,0x10,0x00,  // :
0x00,0x00,0x10,0x00,0x00,0x10,0x10,0x20,  // ;
0x00,0x00,0x08,0x10,0x20,0x10,0x08,0x00,  // <
0x00,0x00,0x00,0x7C,0x00,0x7C,0x00,0x00,  // =
0x00,0x00,0x20,0x10,0x08,0x10,0x20,0x00,  // >
0x00,0x3C,0x42,0x04,0x08,0x00,0x08,0x00,  // ?

0x00,0x3C,0x4A,0x56,0x5E,0x40,0x3C,0x00,  // @
0x00,0x78,0x84,0x84,0xFC,0x84,0x84,0x00,  // A
0x00,0xF8,0x84,0xF8,0x84,0x84,0xF8,0x00,  // B
0x00,0x78,0x84,0x80,0x80,0x84,0x78,0x00,  // C
0x00,0xF0,0x88,0x84,0x84,0x88,0xF0,0x00,  // D
0x00,0xFC,0x80,0xF8,0x80,0x80,0xFC,0x00,  // E
0x00,0xFC,0x80,0xF8,0x80,0x80,0x80,0x00,  // F
0x00,0x78,0x84,0x80,0x9C,0x84,0x78,0x00,  // G
0x00,0x84,0x84,0xFC,0x84,0x84,0x84,0x00,  // H
0x00,0x7C,0x10,0x10,0x10,0x10,0x7C,0x00,  // I
0x00,0x04,0x04,0x04,0x84,0x84,0x78,0x00,  // J
0x00,0x88,0x90,0xE0,0x90,0x88,0x84,0x00,  // K
0x00,0x80,0x80,0x80,0x80,0x80,0xFC,0x00,  // L
0x00,0x84,0xCC,0xB4,0x84,0x84,0x84,0x00,  // M
0x00,0x84,0xC4,0xA4,0x94,0x8C,0x84,0x00,  // N
0x00,0x78,0x84,0x84,0x84,0x84,0x78,0x00,  // O

0x00,0xF8,0x84,0x84,0xF8,0x80,0x80,0x00,  // P
0x00,0x78,0x84,0x84,0xA4,0x94,0x78,0x00,  // Q
0x00,0xF8,0x84,0x84,0xF8,0x88,0x84,0x00,  // R
0x00,0x78,0x80,0x78,0x04,0x84,0x78,0x00,  // S
0x00,0xFE,0x10,0x10,0x10,0x10,0x10,0x00,  // T
0x00,0x84,0x84,0x84,0x84,0x84,0x78,0x00,  // U
0x00,0x84,0x84,0x84,0x84,0x48,0x30,0x00,  // V
0x00,0x84,0x84,0x84,0x84,0xB4,0x48,0x00,  // W
0x00,0x84,0x48,0x30,0x30,0x48,0x84,0x00,  // X
0x00,0x82,0x44,0x28,0x10,0x10,0x10,0x00,  // Y
0x00,0xFC,0x08,0x10,0x20,0x40,0xFC,0x00,  // Z
0x00,0x38,0x20,0x20,0x20,0x20,0x38,0x00,  // [
0x00,0x00,0x40,0x20,0x10,0x08,0x04,0x00,  // <backslash>
0x00,0x38,0x08,0x08,0x08,0x08,0x38,0x00,  // ]
0x00,0x10,0x38,0x54,0x10,0x10,0x10,0x00,  // ^
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,  // _

0x3C,0x42,0x99,0xA1,0xA1,0x99,0x42,0x3C,  // `
0x00,0x00,0x38,0x04,0x3C,0x44,0x3C,0x00,  // a
0x00,0x40,0x40,0x78,0x44,0x44,0x78,0x00,  // b
0x00,0x00,0x1C,0x20,0x20,0x20,0x1C,0x00,  // c
0x00,0x04,0x04,0x3C,0x44,0x44,0x3C,0x00,  // d
0x00,0x00,0x38,0x44,0x78,0x40,0x3C,0x00,  // e
0x00,0x0C,0x10,0x18,0x10,0x10,0x10,0x00,  // f
0x00,0x00,0x3E,0x42,0x42,0x3E,0x02,0x3C,  // g
0x00,0x40,0x40,0x78,0x44,0x44,0x44,0x00,  // h
0x00,0x08,0x00,0x18,0x08,0x08,0x1C,0x00,  // i
0x00,0x04,0x00,0x04,0x04,0x04,0x24,0x18,  // j
0x00,0x40,0x50,0x60,0x60,0x50,0x48,0x00,  // k
0x00,0x10,0x10,0x10,0x10,0x10,0x0C,0x00,  // l
0x00,0x00,0x68,0x54,0x54,0x54,0x54,0x00,  // m
0x00,0x00,0x78,0x44,0x44,0x44,0x44,0x00,  // n
0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00,  // o

0x00,0x00,0x78,0x44,0x44,0x78,0x40,0x40,  // p
0x00,0x00,0x3C,0x44,0x44,0x3C,0x04,0x06,  // q
0x00,0x00,0x1C,0x20,0x20,0x20,0x20,0x00,  // r
0x00,0x00,0x38,0x40,0x38,0x04,0x78,0x00,  // s
0x00,0x10,0x38,0x10,0x10,0x10,0x0C,0x00,  // t
0x00,0x00,0x44,0x44,0x44,0x44,0x38,0x00,  // u
0x00,0x00,0x44,0x44,0x28,0x28,0x10,0x00,  // v
0x00,0x00,0x44,0x54,0x54,0x54,0x28,0x00,  // w
0x00,0x00,0x44,0x28,0x10,0x28,0x44,0x00,  // x
0x00,0x00,0x44,0x44,0x44,0x3C,0x04,0x38,  // y
0x00,0x00,0x7C,0x08,0x10,0x20,0x7C,0x00,  // z
0x00,0x1C,0x10,0x60,0x10,0x10,0x1C,0x00,  // {
0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x00,  // |
0x00,0x70,0x10,0x0C,0x10,0x10,0x70,0x00,  // }
0x00,0x14,0x28,0x00,0x00,0x00,0x00,0x00   // ~
]

public enum LCDColor:UInt8{
    case BLACK
    case WHITE
}
 
//Internal Constants

internal let PCD8544_POWERDOWN=0x04
internal let PCD8544_ENTRYMODE=0x02
internal let PCD8544_EXTENDEDINSTRUCTION=0x01

internal let PCD8544_DISPLAYBLANK=0x0
internal let PCD8544_DISPLAYNORMAL=0x4
internal let PCD8544_DISPLAYALLON=0x1
internal let PCD8544_DISPLAYINVERTED=0x5

// H = 0
internal let PCD8544_FUNCTIONSET=0x20
internal let PCD8544_DISPLAYCONTROL=0x08
internal let PCD8544_SETYADDR=0x40
internal let PCD8544_SETXADDR=0x80
// H = 1
internal let PCD8544_SETTEMP=0x04
internal let PCD8544_SETBIAS=0x10
internal let PCD8544_SETVOP=0x80


